---
title: "Introduction to R for Data Analysis"
subtitle: "Data Types, Import & Export"
author: "Johannes Breuer & Stefan JÃ¼nger"
date: "2021-08-02"
presenter: Stefan
---
layout: true 

```{r child = "../config/sessions_setup.Rmd"}
```

---

## Getting data into `R`
Thus far, we've already learned what `R` and `RStudio` are. This course is about starting to use `R` and feeling prepared to use it for statistical analyses. There's one essential prerequisite:

.center[**We need data!**]

```{r, out.width = "50%", echo = FALSE}
woRkshoptools::include_picture("./import_data.png")
```

---

## Content of this session 

- What are `R`'s internal data types?
- How to work with different data types?
- How to import data in different formats?
- How to export data in different formats

---

## Data we use in this course
During the course, we use several different datasets. Mainly in this session, where we apply different importing functions, we use a large variety ranging from data about the Titanic to data about unicorns. However, we will also use data that are (presumably) more interesting for social and behavioral scientists.

---

## It boils down to...
.pull-left[
**How your data are stored (data types)**
- 'Numbers' (Integers & Doubles)
- Character Strings
- Logical
- Factors
- ...
- There's more, e.g., expressions, but let's leave it at that
]

.pull-right[
**Where your data are stored (data formats)**
- Vectors
- Matrices
- Arrays
- Data frames / Tibbles
- Lists
]

.footnote[https://www.stat.berkeley.edu/~nolan/stat133/Fall05/lectures/DataTypes4.pdf]

---

## Numeric data
.small[
*Integers* are values without a decimal value. To be explicit in `R` in using them, you have to place an `L` behind the actual value, just like that:

```{r integer-1}
1L
```

By contrast, *doubles* are values with a decimal value.

```{r integer-2}
1.1
```

We can check data types by using the `typeof()` function.

```{r typeof}
typeof(1L)
typeof(1.1)
```
]

---

## Character strings
At first glance, a *character* is a letter somewhere between a-z. *String* in this context might mean that we have a series of characters. However, numbers and other symbols can be part of a *character string*, which can then be, e.g., part of a text. In `R`, character strings are wrapped in quotation marks.

```{r string}
"Hi. I am a character string, the 1st of its kind!"
```

So character strings are meaningless, which means that there are no values associated with their content unless we change that, e.g., with factors.

---

## Factors
If you're a *Stata* (or *SPSS*) user, you may already be quite familiar with factors. Factors are data types that assume that their values are not continuous, e.g., as in ordinal or nominal data. They are useful when inserted into regression models, as we will see later in this course.

```{r factor}
factor(1.1)
factor("Hi. I am a character string, the 1st of its kind!")
```

Factors take numeric data or character strings as input as they simply convert them into so-called levels. This concept may be a little bit abstract for the time being. It's just essential to have heard about them before you learn more about them in the data wrangling session.

---

## Logical values
Logical values are basically either `TRUE` or `FALSE` values. These values are produced by making logical requests on your data.

```{r logical}
2 > 1
2 < 1
```

I'd say that logical values are at the heart of creating loops. For this purpose, we need way more logical operators to request `TRUE` or `FALSE` values.

---

## Logical operators
Here are all (?) logical operators in `R`:
- `<` 	less than
- `<=` 	less than or equal to
- `>` 	greater than
- `>=` 	greater than or equal to
- `== `	exactly equal to
- `!=` 	not equal to
- `!x` 	Not x
- `x | y` 	x OR y
- `x & y `	x AND y
- `isTRUE(x)` 	test if X is TRUE 
- `isFALSE(x)` 	test if X is FALSE 

.footnote[https://www.statmethods.net/management/operators.html]

Moreover, there are some more `is.PROPERTY_ASKED_FOR()` functions, such as `is.numeric()`, which also return `TRUE` or `FALSE` values.

---

## `R`'s data formats 
`R`'s different data types can be put into 'container's.

```{r containers, echo = FALSE, out.width = "75%"}
woRkshoptools::include_picture("9213.1526125966.png")
```

.footnote[https://devopedia.org/r-data-structures]

---

## Vectors
Vectors are built by enclosing your content with `c()` ("c" for "concatenate")

```{r vectors}
numeric_vector   <- c(1, 2, 3, 4)
character_vector <- c("a", "b", "c", "d")

numeric_vector
character_vector
```

Vectors are really like vectors in mathematics. Initially, it doesn't matter if you look at them as column or row vectors.

---

## ...but it matters when you combine vectors
Using the function `cbind()` or `rbind()` you can either combine vectors column-wise or row-wise, respectively.

```{r combine-vectors}
cbind(numeric_vector, character_vector)
rbind(numeric_vector, character_vector)
```

They are now matrices (also numeric values are coerced into strings).

---

## Matrices
Matrices are the basic rectangular data format in R.

```{r matrix}
fancy_matrix <- matrix(1:16, nrow = 4)

fancy_matrix
```

You cannot store multiple data types, such as strings and numeric values in the same matrix.  Otherwise, your data will get coerced to a common type, as seen in the previous slide.
- In fact, this is something that happens already within vectors.

```{r vector-coercion}
c(1, 2, "evil string")
```

---

## Data frames
While matrices are used, e.g.,--\*drumroll\*-- for matrix operations, data frames resemble more the data formats most of you are probably already familiar with. We can build data frames by hand as here:

.tinyish[
```{r data-frames, eval = FALSE}
library(randomNames) # a name generator package

fancy_data <-
  data.frame( 
    who = 
      randomNames(n = 10, which.names = "first"),
    age = 
      sample(14:49, 10, replace = TRUE), # you see what we are doing here?   
    salary_2018 = 
      sample(15:100, 10, replace = TRUE),  
    salary_2019 = 
      sample(15:100, 10, replace = TRUE)
  )
 
fancy_data
```
]

.right[`r emo::ji("left_arrow_curving_right")`]

---
class: middle
```{r ref.label = "data-frames", echo = FALSE}
```

---

## Tibbles

.pull-left[
Tibbles are basically just `R data.frames` but nicer.

- only the first ten observations are printed
  - output is tidier!
  
- you get some additional metadata about rows and columns that you would normally only get when using `dim()` and other functions

You can check the [tibble vignette](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html) for technical details.
]

.pull-right[
```{r tibble-pic, echo = FALSE, out.width="60%"}
woRkshoptools::include_picture("./tibble.png")
```
]

---

class: middle

```{r as_tibbles}
library(tibble)
as_tibble(fancy_data)
```

---

## One last type you should know: lists
Lists are perfect for storing numerous and potentially diverse information in one place.

```{r fancy_list, eval = FALSE}
fancy_list <- 
  list(
    numeric_vector,
    character_vector,
    fancy_matrix,
    fancy_data
  )

fancy_list
```

.right[`r emo::ji("left_arrow_curving_right")`]

---
class: middle
.tinyish[
```{r ref.label = "fancy_list", echo = FALSE}
```
]

---

## Nested lists
```{r fancy_nested_list, eval = FALSE}
fancy_nested_list <-
  list(
    fancy_vectors = list(numeric_vector, character_vector),
    data_stuff = list(fancy_matrix, fancy_data)
  )

fancy_nested_list
```

.right[`r emo::ji("left_arrow_curving_right")`]

---
class: middle
.tinyish[
```{r ref.label = "fancy_nested_list", echo = FALSE}
```
]

---

## Accessing elements by index
Generally, there is this use of `[index_number]`-logic in `R` to access only a subset of information in data, no matter if we have vectors or data frames.

Say, we want to extract the second element of our `character_vector` object, we could do that like this:

```{r}
character_vector[2]
```

---

# More complicated cases: matrices
Matrices can have more dimensions, often you want information from a specific row and column.

```{r eval = FALSE}
a_wonderful_matrix[number_of_row, number_of_column]
```

*Note*: You can do the same indexing with `data.frame`s

---

## Matrices and subscripts (as in mathematical notation)
Identify rows, columns, or elements using subscripts is similar to matrix  notation:

```{r eval = FALSE}
fancy_matrix[, 4] # 4th column of matrix
fancy_matrix[3,] # 3rd row of matrix
fancy_matrix[2:4, 1:3] # rows 2,3,4 of columns 1,2,3 
```

It's really like in math, and you can perform standard mathematical operations, such as matrix multiplications.

```{r}
fancy_matrix[2:4, 1:3] %*% fancy_matrix[1:3, 2:4]
```

---

## The case of data frames
A nice feature of `data.frames` or `tibbles` is that their columns are names, just as variable names in ordinary data. It would be cumbersome do use index numbers to extract a specific column/variable, right? Do not fear:

```{r}
fancy_data$who
```

Just place a `$`-sign between the data object and the variable name.

---

## `[]` in data frames
Sometimes we also have to rely on character strings as input information, e.g., for iterating over data. We can also use `[]` to access variables by name. 

.pull-left[ 
Not only this way:

```{r}
fancy_data[1]
```
]

.pull-right[
But also this way:

```{r}
fancy_data["who"]
```
]


---

## Dataframe check 1, 2, 1, 2!

Even before checking the codebook for a dataset (if there is one) it always helps to have a quick look at the data. The most high-level information you can get is about the object type and its dimensions.

.small[
```{r class-dim}
# object type
class(gp_covid)

# number of rows and columns
dim(gp_covid)

# number of rows
nrow(gp_covid)

# number of columns
ncol(gp_covid)
```
]

---

## Dataframe check 1, 2, 1, 2!

You can also print the first 6 lines of the dataframe with `head()`. You can easily change the number of lines by providing the number as the second argument to the `head()` function.

```{r head}
head(gp_covid, 10)
```

---

## Dataframe check 1, 2, 1, 2!

If we want some more (detailed) information about the dataset, we can use the `base R` function `str()`.

```{r str, eval = F}
str(gp_covid)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "str", echo = F}
```
]

---

## Dataframe check 1, 2, 1, 2!

As you saw on the previous slide, the output of `str()` can be a bit hard to read (especially for larger datasets). A good alternative that creates a more clearly laid output is the `glimpse()` function from the `dplyr` package.

```{r glimpse, eval = F}
glimpse(gp_covid)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "glimpse", echo = F}
```
]

---

## Dataframe check 1, 2, 1, 2!

If you want to have a look at your full dataset, you can use the `View()` function. In *RStudio*, this will open a new tab in the source pane through which you can explore the dataset (including a search function). You can also click on the small spreadsheet symbol on the right side of the object in the environment tab to open this view. 

```{r view, eval = F}
View(gp_covid)
```

```{r, view-pic, out.width = "65%", echo = F}
woRkshoptools::include_picture("./rstudio_view.png")
```


---

## Difference between `[]` and `[[]]` 

```{r echo = FALSE}
woRkshoptools::include_picture("indexing_lists.png")
```

.footnote[https://twitter.com/hadleywickham/status/643381054758363136/photo/1]

---

## Receiving and defining names

We can print all names of an object using the `names()` function...

```{r receiving-names}
names(fancy_data)
```

...and we can change its names with it.

```{r changing-names}
names(fancy_data) <- c("name", "salary_2018", "salary_2019")

names(fancy_data)
```

However, there are more flexible ways of doing this as we will see later.

---

class: center, middle


# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_1_2_1_Data_Types.html) time `r emo::ji("weight_lifting_woman")``r emo::ji("muscle")``r emo::ji("running_man")``r emo::ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/solutions/Exercise_1_2_1_Data_Types.html)


---

## GESIS Panel Data on the Coronavirus Outbreak
.left-column[
```{r echo = FALSE}
woRkshoptools::include_picture("./gesis_panel_logo_web.jpg")
```
]

.right-column[
For most of the examples and exercises in this course we will use the [Public Use File (PUF) of the GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany](https://www.gesis.org/gesis-panel/coronavirus-outbreak/public-use-file-puf). You can [download the dataset in different formats as well as the codebook and the questionnaire (in German) from the *GESIS* Data Archive](https://search.gesis.org/research_data/ZA5667) (note: you need to have/create a user account).

The *GESIS Panel* website provides [detailed documentation](https://www.gesis.org/gesis-panel/documentation), including a [cheatsheet](https://www.gesis.org/fileadmin/upload/forschung/programme_projekte/Drittmittelprojekte/GESIS_Panel/gesis_panel_cheatsheet.pdf).
]

---

## Gapminder Data
.left-column[ 
```{r echo = FALSE}
woRkshoptools::include_picture("./gapminder_logo.png")
```
]

.right-column[
We will also use [data from *Gapminder*](https://www.gapminder.org/data/). During the course and the exercises, we work with data we have downloaded from their website. There also is an `R` package that bundles some of the *Gapminder* data: `install.packages("gapminder")`.

This `R` package provides ["[a]n excerpt of the data available at Gapminder.org. For each of 142 countries, the package provides values for life expectancy, GDP per capita, and population, every five years, from 1952 to 2007."](https://cran.r-project.org/web/packages/gapminder/index.html)
]

---

## How to use the data in general
To code along and be able to do the exercises, you should store the data files for the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* in a folder called `data` in the same folder as the other materials for this course.

The *Gapminder* data (as well as the Titanic and unicorn) should already be in the `data` folder (if you downloaded/cloned the materials from the [*GitHub* repo for this course](https://github.com/jobreu/r-intro-gesis-2021)). We also provide you a synthetic data set based on the GESIS Panel data. This synthetic data set was created by [Bernd WeiÃ](https://berndweiss.net/) using the [`synthpop` package](https://www.synthpop.org.uk/).

---

## `R` is data-agnostic
```{r, echo = FALSE, out.width = "65%"}
woRkshoptools::include_picture("./Datenimport.PNG")
```

---

## But the choice of packages is intimidating
.pull-left[
**What you will learn**
- Getting the most common data formats into `R`
  - e.g., CSV, *Stata*, *SPSS*, or *Excel* spreadsheets
- Using the most recent methods of doing that
- We will rely a lot on packages and functions from the `tidyverse` instead of using `base R`
]

.pull-right[
**What you won't learn**
- Getting old & obscure binary data formats into `R`
  - ... although [it's possible](https://cran.r-project.org/doc/manuals/r-release/R-data.html)
]

---

## Before writing any code: *RStudio* functionality to import data
`R` is no longer just for command line heroes. In the *RStudio* IDE menu, you can also select and load your data using the mouse. It's under `Environment - Import Dataset - Choose file type`.

```{r, echo = FALSE}
woRkshoptools::include_picture("./rstudio_import.PNG")
```

---

## Where to find data

**Browse Button in `RStudio`**
```{r, echo = FALSE, out.width="75%"}
woRkshoptools::include_picture("./importBrowse.PNG")
```

**Code preview in `Rstudio`**
```{r, echo = FALSE, out.width="75%"}
woRkshoptools::include_picture("./codepreview.PNG")
```

---

## Honestly, after some time you will write the code directly
.center[
```{r, echo = FALSE}
woRkshoptools::include_picture("./coding_cat.gif")
```
]

.footnote[[Source](https://media.giphy.com/media/LmNwrBhejkK9EFP504/source.gif)]

---

## Simple vs. not so simple file formats

Basic file formats, such as CSV (comma-separated value file), can directly be imported into `R`
- they are 'flat'
- few metadata
- basically text files

Other file formats, particularly the proprietary ones, require the use of additional packages
- they are complex
- a lot of metadata (think of all the labels in an *SPSS* file)
- they are binary (1110101)


---

## File formats are subject of war

```{r echo = FALSE, out.width = "30%"}
woRkshoptools::include_picture("./norm_normal_file_format.png")
```
https://xkcd.com/2116/

---

## Personal sidenote: why `tidyverse` for importing?
For simple files, `base R` provides proper tools for importing.

Yet, for importing other files, we have to rely on additional packages anyway.
- the `tidyverse` packages (and its "friends") allow us to import and export all kinds of different data formats in a coherent way
- the tidy data format also facilitates adding metadata to imported data
  - they are tibbles
  - a specific kind are labelled data (more on that in a bit)
- the `tidyverse` provides some sane defaults, e.g., by automatic data type detection

---

## Disclaimer

**In the following slides, we'll jump right into importing data. We use a lot of different packages for this purpose, and you don't have to remember everything. It's just for making a point of how agnostic `R` actually is regarding the file type. Later on, we will dive more into the specifics of importing.**

---

## For starters: Importing a CSV file using `Base R`

```{r loadtitanic, eval = FALSE}
titanic <- read.csv("./data/titanic.csv")

titanic
```

.tiny[
```{r loadtitanic-print, echo = FALSE}
titanic <- read.csv("./data/titanic.csv")

titanic
```
]



---

## A `tidyverse` / `readr` example
```{r readr-example}
library(readr)

titanic <- read_csv("./data/titanic.csv")
```

Please note the column specifications. `readr` 'guesses' them based on the first 1000 observations (we will come back to this later).

---
class: middle
.tinyish[
```{r readr-example-output, echo = TRUE}
titanic
```
]

It's that easy!

---

## A `readxl` example: `read_excel()`
```{r readxl-example}
library(readxl)

unicorns <- read_xlsx("./data/observations.xlsx")
```

No output `r emo::ji("frowning_face")`

---
class: middle
```{r readxl_example_output, echo = TRUE}
unicorns
```

---

## A `haven` example: `read_stata()` 
```{r read-stata-example-display}
library(haven)

gp_covid <- 
  read_stata("./data/ZA5667_v1-1-0_Stata14.dta")
```

---

```{r read-stata-example_output, echo = TRUE}
gp_covid
```

---

## `read_stata()`'s sister: `read_spss()`
Indeed, there's also the function `read_spss()` to import *SPSS* files.

It also provides capabilities to handle *SPSS*-defined missing values by setting the option `user_na = TRUE` (default is `FALSE`).

*Note*: The [`sjlabelled` package](https://cran.r-project.org/web/packages/sjlabelled/index.html) can also be used to choose a more elaborated approach for missing values: https://cran.r-project.org/web/packages/sjlabelled/vignettes/intro_sjlabelled.html

**We will come back to Stata and SPSS files since they depict a specific file format in `R`: labelled data.**

---

## There's more
These were just some very first examples of applying functions from each package. They comprise even more functions for different data types.

- `readr`
  - `read_csv()`
  - `read_tsv()`
  - `read_delim()`
  - `read_fwf()`
  - `read_table()`
  - `read_log()`
- `haven`
  - `read_sas()`
  - `read_spss()`
  - `read_stata()`

Not to mention all the helper functions and options. For example, we can define the cells to read from an *Excel* file by specifying the option `range = "C1:E4"` in `read_excel()`

---

## Data type specifications for `tibbles` 
- characters
  - indicated by `<chr>`
  - specified by `col_character()`
- integers
  - indicated by `<int>`
  - specified by `col_integer()`
- doubles
  - indicated by `<dbl>`
  - specified by `col_double()`
- factors
  - indicated by `<fct>`
  - specified by `col_factor()`
- logical
  - indicated by `<lgl>`
  - specified by `col_logical()`
  
.center[**There's more, but we'll leave it at that for now.**]

---

## Changing variable types, e.g., in CSV files
As mentioned before, `read_csv` 'guesses' the variable types by scanning the first 1000 observations. **NB**: This can go wrong!

Luckily, we can change the variable type...
- before/while loading the data
- and after loading the data

---

## While loading the data in `read_csv`
.tinyish[
```{r readr-example-col-change}
titanic <-
  read_csv(
    "./data/titanic.csv",
    col_types = cols(
      PassengerId = col_double(),
      Survived = col_double(),
      Pclass = col_double(),
      Name = col_character(),
      Sex = col_character(),
      Age = col_double(),
      SibSp = col_double(),
      Parch = col_double(),
      Ticket = col_character(),
      Fare = col_double(),
      Cabin = col_character(),
      Embarked = col_character()
    )
  )

titanic
```
]

.right[`r emo::ji("left_arrow_curving_right")`]

---
.tinyish[
```{r ref.label = "readr-example-col-change", echo = FALSE}
```
]

---

## While loading the data in `read_csv`
.tinyish[
```{r readr-example-col-changeD-display}
titanic <-
  read_csv(
    "./data/titanic.csv",
    col_types = cols(
      PassengerId = col_double(),
      Survived = col_double(),
      Pclass = col_double(),
      Name = col_character(),
      Sex = col_factor(), # This one changed!
      Age = col_double(),
      SibSp = col_double(),
      Parch = col_double(),
      Ticket = col_character(),
      Fare = col_double(),
      Cabin = col_character(),
      Embarked = col_character()
    )
  )

titanic
```
]

.right[`r emo::ji("left_arrow_curving_right")`]

---
.tinyish[
```{r ref.label = "readr-example-col-changeD", echo = FALSE}
```
]

---

## After loading the data

```{r readr_example_col_changeD_after, echo = TRUE}
titanic <-
  readr::type_convert(
    titanic,
    col_types = cols(
      PassengerId = col_double(),
      Survived = col_double(),
      Pclass = col_double(),
      Name = col_character(),
      Sex = col_factor(),
      Age = col_double(),
      SibSp = col_double(),
      Parch = col_double(),
      Ticket = col_character(),
      Fare = col_double(),
      Cabin = col_character(),
      Embarked = col_character()
    )
  )
```

---

## Beyond flat files: labelled data
A lot of data you get and find or even collect comes in some sort of flat file format, such as CSV. In the social sciences, however, we often deal with proprietary file formats, such as *SPSS*'s `.sav` or *Stata*'s `.dta` files. 

What we often find in these data are labels. These labels are used to describe variables or variable values. They comprise some specific metadata inherent in these proprietary file formats. 

*If you were able to travel ten years back in time and ask an `R` geek, she'd say that you cannot use labels in R. You'd either have to import, e.g., value labels as character strings or use their codes as factors. However, these days...*

---

## Not being able to use labelled data is the past
Nowadays, if you use the `haven` package, labels are built-in. For example:

```{r}
gp_covid["age_cat"]
```

---

## Advantages of using labelled data
One could rejoice in not having to use a codebook any more, just like in *SPSS*. And I think by and large this is true, although just looking at code output for glimpsing at data is somewhat... geeky. 

An advantage definitely is that you could re-use the labels in figures and plots, some packages do that automatically, such as the [`sjPlot`](https://strengejacke.github.io/sjPlot/) package.

Yet, primarily when you exchange your data with colleagues who do not use `R` or when you plan to publish your data (which you always should if that is possible), being able to export data you have manipulated in `R` is great.
- ... and, yes, you can do that with labelled data as well.

**However, be aware of the missing values hell that you may have to enter due to different missing values definitions in Stata and SPSS.**

---

## Manipulating labels
I used to be a data ingest and preparation guy at the *GESIS* Data Archive. For this job, I had to use *SPSS* or *Stata* for my work, albeit 'privately' I worked with `R` all the time for my dissertation. I would have let Elon Musk name my firstborn child<sup>1</sup>, if I could have been able to perform all these tasks in `R`.

Luckily, the generation after me at least could start to use `R` now for labeling or relabelling data with additional packages. One of those is the `sjlabelled` package from Daniel LÃ¼decke.

.footnote[
[1]The name of his child is X Ã A-12
]

---

## Getting labels

### Variables 
```{r}
sjlabelled::get_label(gp_covid$age_cat)
```

### Values
.tinyish[
```{r}
sjlabelled::get_labels(gp_covid$age_cat)
```
]

---

## And setting labels: Variables

```{r}
gp_covid$age_cat <- 
  sjlabelled::set_label(gp_covid$age_cat, label = "Age, categorized")

sjlabelled::get_label(gp_covid$age_cat)
```

---

## And setting labels: Values
.tinyish[
```{r}
gp_covid$age_cat <- 
  sjlabelled::set_labels(
    gp_covid$age_cat,
    labels = 
      c(
        "<=25 years", "26 to 30 years", "31 to 35 years", "36 to 40 years",
        "41 to 45 years", "46 to 50 years", "51 to 60 years", 
        "61 to 65 years", "66 to 70 years", ">=71 years"
      )
  )

sjlabelled::get_labels(gp_covid$age_cat)
```
]

---

## That's a lot of manual work
Yeah, this requires some tedious manual work that has to be done, at least by somebody. But that's just how it is, even in *SPSS* or *Stata*. Indeed, we may want to wait until using it in `R` scales a bit more. Integrating basic labelling of variables in a pipe workflow, however, is already straightforward:

```{r}
gp_data_subset <-
  gp_covid %>% 
  dplyr::select(age_cat, sex) %>% 
  sjlabelled::var_labels(
    age_cat = "Age in Categories",
    sex = "Gender in Binary Form"
  )

sjlabelled::get_label(gp_data_subset)
```

Ok, but that's already data wrangling, a topic for this afternoon.

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_1_2_2_Flat_Files.html) time `r emo::ji("weight_lifting_woman")``r emo::ji("muscle")``r emo::ji("running_man")``r emo::ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/solutions/Exercise_1_2_2_Flat_Files.html)

---

## Exporting data
Sometimes our data have to leave `R`, for example, if we....
- share data with colleagues who do not use `R`
- want to continue where we left off
  - particularly if data wrangling took a long time
  
For such purposes we also need a way to export our data.

All of the packages we have discussed in this session also have designated functions for that.

```{r, out.width = "50%", echo = FALSE}
woRkshoptools::include_picture("./export_data.png")
```

---

## Examples: CSV and Stata files
```{r export_csv, echo = TRUE}
write_csv(titanic, "titanic_own.csv")
```

```{r export_stata, echo = TRUE}
write_dta(titanic, "titanic_own.dta")
```

Proof that they have been exported:
```{r list_files, echo = TRUE}
list.files() 
```

---

## `R`'s native file formats
If you plan to continue to work with `R` (something we would always recommend `r emo::ji("stuck_out_tongue_winking_eye")`), there are at least two native 'file formats' to choose from. The advantage of using them is that they are compressed files, so that they don't occupy unnecessarily large disk space. Moreover, they are already prepared as you left them, and they take less time to be loaded (not a big deal in a small data world but relevant for big(ger) data).

`.Rdata`/`.rda` files saving and loading:

```{r, eval = FALSE}
save(mydata, file = "mydata.RData")
load("mydata.RData")
```

`.rds` files saving and loading.

```{r, eval = FALSE}
saveRDS(mydata, "mydata.rds")
mydata <- readRDS("mydata.rds")
```


`saveRDS()` just saves a representation of the object, which means you can name it whatever you want when loading.

---

## Saving just everything
If you have not changed the General Global Options in *RStudio* as suggested in the *Getting Started* session, you may have noticed that, when closing *Rstudio*, by default, the programs asks you whether you want to save the workspace image. 

```{r, out.width = "50%", echo = FALSE}
woRkshoptools::include_picture("./save_image.png")
```

You can also do that whenever you want using the `save.image()` function:

```{r, eval = FALSE}
save.image(file = "my_fancy_workspace.RData")
```

---

## Additional packages
The great benefit of `tidyverse` import functions is the import of the data as tibbles: the data are potentially tidier.

Several other non-tidyverse packages provide similar benefits as they make use of this universal data format:
- [`sf`](https://github.com/r-spatial/sf) for geospatial data

- [`sjlabelled`](https://cran.r-project.org/web/packages/sjlabelled/index.html) to work with labelled data, e.g., from *SPSS* or *Stata*

---

## Other packages for data import

- `base` R
- the [`foreign` package](https://cran.r-project.org/web/packages/foreign/index.html) for *SPSS* and *Stata* files
- [`data.table`](https://cran.r-project.org/web/packages/data.table/index.html) or [`fst`](https://www.fstpackage.org/) for large datasets
- [`jsonlite`](https://cran.r-project.org/web/packages/jsonlite/index.html) for `.json` files
- [`datapasta`](https://github.com/MilesMcBain/datapasta) for copying and pasting data into tribbles (e.g., from websites, *Excel* or *Word* files)


---

## Final note on file paths
There is this simple rule of never using absolute file paths to maintain your code reproducibly and future-proof. We already talked about this in the introduction, so it's just to remind you as this is particularly important for data importing and exporting.

```{r eval = FALSE}
# Windows
load("C:/Users/cool_user/data/fancy_data.Rdata")

# Mac
load("/Users/cool_user/data/fancy_data.Rdata")

# GNU/Linux
load("/home/cool_user/data/fancy_data.Rdata")
```

---

## Use relative paths
Instead of using absolute paths, it is recommended to use relative file paths. The general principle here is to start from a directory where your current script currently exists and navigate to your target location. Say we are in the "C:/Users/cool_user/" location on a Windows machine. To load your data, we would use:

```{r eval = FALSE}
load("./data/fancy_data.Rdata")
```

If we were in a different folder, e.g., "C:/Users/cool_user/cat_pics/mauzi/", we would use:

```{r eval = FALSE}
load("../../data/fancy_data.Rdata")
```

---

class: center, middle

Please first download the [Public Use File (PUF) of the GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany](https://search.gesis.org/research_data/ZA5667) as .sav, .dta, and .csv file.

# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_1_2_3_Statistical_Software_Files.html) time `r emo::ji("weight_lifting_woman")``r emo::ji("muscle")``r emo::ji("running_man")``r emo::ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/solutions/Exercise_1_2_3_Statistical_Software_Files.html)