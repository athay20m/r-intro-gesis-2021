---
title: "Introduction to R for Data Analysis"
subtitle: "Data Wrangling Advanced"
author: "Johannes Breuer & Stefan JÃ¼nger"
date: "2021-08-03"
presenter: Stefan
---
layout: true 

```{r child = "../config/sessions_setup.Rmd"}
```

---

## Data wrangling continued `r ji("cowboy_hat_face")`

While in the last sessions we focused on the bread-and-butter tasks of the data preparation business, in this part we will focus on the more 'programmy' side of things.

- altering the content of a whole set of variables
- conditional variable transformation
- formulating logical requests to our data
- writing loops

---

class: middle

**We will switch between the world of `base R` and the `tidyverse` as it also a good lesson that it is not necessary to rely either on one of them. Yet, for both we cannot be comprehensive, which is why we will show routines that may be important for your first steps after the course and for the rest of the week.**

---

## Load the data

Again, we will work with the *Public Use File (PUF) of the GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* as `.csv` file.

```{r load-gesis-panel-data}
gp_covid <- read_csv2("./data/ZA5667_v1-1-0.csv")
```

---

## Quickly define missing values

```{r set-missings}
library(sjlabelled)

gp_covid <-
  gp_covid %>%
  set_na(na = c(-99, -77, -33, 97, 98))
```

---

## Variables of interest

Say, we are interested in the (dis)trust towards several authorities during the Corona crisis. There are 9 items on this topic. Let's create some quick on 3 of them.

```{r quick-table}
table(gp_covid$hzcy044a)
table(gp_covid$hzcy047a)
table(gp_covid$hzcy052a)
```

What if we want to conduct some data reduction method (e.g., PCA) and need the variables in reverse order for interpretation purposes?

---

## Recode data **across** defined variables 

The `dplyr` package provides a (new) handy tool to exactly this: `across()`. This function can be used to apply another function to multiple variables at once.

```{r recode-across}
gp_covid <- 
  gp_covid %>% 
  mutate(
    across(
      hzcy044a:hzcy052a,
      ~recode(
        .x,
        `5` = 1, # `old value` = new value
        `4` = 2,
        `2` = 4,
        `1` = 5
      )
    )
  )
```

---

class: middle

```{r quick-table-2}
table(gp_covid$hzcy044a)
table(gp_covid$hzcy047a)
table(gp_covid$hzcy052a)
```

---

## Using `across()` across logical conditions

Sometimes we are interested in variables that meet certain conditions. For example, for an anylsis, we want to z-standardize all numeric variables in a dataset. Let's create a temporary subset of our data to exemplify such efforts.

```{r create-tmp-dataset}
gp_covid_tmp <-
  gp_covid %>% 
  select(doi, hzcy044a:hzcy052a)

gp_covid_tmp %>% 
  sample_n(5)  # randomly sample 5 cases from the df
```

---

## Example: z-standardize all numeric variables

The `base R` function to z-standardize a variable is `scale()`.

```{r scale-vars}
gp_covid_tmp <-
  gp_covid_tmp %>% 
  mutate(
    across(
      is.numeric,
      ~scale(.x)
    )
  )

gp_covid_tmp %>% 
  sample_n(5)
```

---

## `dplyr::across()`

```{r, across-cartoon, out.width = "95%", echo = F}
woRkshoptools::include_picture("across_blank.png")
```
<small><small>Artwork by [Allison Horst](https://github.com/allisonhorst/stats-illustrations)</small></small>

---

## Aggregate variables across rows

Something we might want to do for our analyses is to create aggregate variables, such as sum or mean scores for a set of items.
As `dplyr` operations are applied to columns, whereas such aggregations relate to rows (i.e., respondents), we need to make use of the function `rowwise()`. Say, for example, we want to compute a sum score for all measures that respondents have reported to engage in to prevent an infection with or the spread of the Corona virus.

```{r rowwise-sum}
gp_covid <- 
  gp_covid %>% 
  rowwise() %>%
  mutate(
    sum_trust = 
      sum(
        c_across(hzcy044a:hzcy052a),
        na.rm = TRUE
      )
  ) %>% 
  ungroup()
```

---

## Aggregate variables

Three things to note here: 

1. `c_across()` is a special version of `across()`for rowwise operations. 

2. We use the `ungroup()` function at the end to ensure that `dplyr` verbs will operate the default way when we further work with the `gpc` object. We do not cover grouping in this course (which is especially valuable for summarizing data), but you can check out the [documentation for `group_by()`](https://dplyr.tidyverse.org/reference/group_by.html) to learn more about this.

3. If you only need sums or means, a somewhat faster alternative is using the base `R` functions `rowSums()` and `rowMeans()` in combination with `mutate()` (and possibly also `across()` plus selection helpers). For an explanation why this can be faster, you can read the [online documentation for `rowwise()`](https://dplyr.tidyverse.org/articles/rowwise.html).

---

## Aggregate variables

```{r rowwise-sum-output}
gp_covid %>% 
  select(hzcy044a:hzcy052a, sum_trust) %>% 
  glimpse()
```

---

## Example: Aggregate variables based on means

Rowwise transformations work the same way for means. Here, we create a mean score for the items that ask how much people trust specific people or institutions in dealing with the Corona virus. 

```{r rowwise-mean}
gp_covid <- 
  gp_covid %>%  
  rowwise() %>% 
  mutate(
    mean_trust = 
      mean(
        c_across(hzcy044a:hzcy052a), 
        na.rm = TRUE
      )
  ) %>% 
  ungroup()
```

---

class: middle

```{r rowwise-mean-output}
gp_covid %>% 
  select(hzcy044a:hzcy052a, mean_trust) %>% 
  glimpse()
```

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_2_2_1_Across_the_Tidyverse.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/solutionsExercise_2_2_1_Across_the_Tidyverse.html)

---

class: middle

**Sometimes, things are a bit more complicated. Simple recoding is insufficient when we need to base new variables based on the values of old variable(s). Such procedures are can be called conditional transformation.**

---

## Simple conditional transformation

The simplest version of a conditional variable transformation is using an `ifelse()` statement.

```{r mutate-ifelse}
gp_covid <- 
  gp_covid %>% 
  mutate(
    high_education = 
      ifelse(education_cat == 3, "high", "not so high")
  )

gp_covid %>% 
  select(education_cat, high_education) %>% 
  sample_n(5)
```

.small[
*Note*: A more versatile option for creating dummy variables is the [`fastDummies` package](https://jacobkap.github.io/fastDummies/).
]

---

## Advanced conditional transformation

For more flexible (or complex) conditional transformations, the `case_when()` function from `dyplyr` is a powerful tool.

```{r case-when}
gp_covid <- 
  gp_covid %>% 
  mutate(
    pol_leaning_cat = 
      case_when(
        between(political_orientation, 0, 3) ~ "left",
        between(political_orientation, 4, 7) ~ "center",
        political_orientation > 7 ~ "right"
      )
  )

gp_covid %>% 
  select(political_orientation, pol_leaning_cat) %>% 
  sample_n(5)
```

---

## Conditional transformation based on multiple values

```{r case-when-2}
gp_covid <- 
  gp_covid %>% 
  mutate(
    pol_leaning_edu = 
      case_when(
        between(political_orientation, 0, 3) & high_education == "high" ~ "left high",
        between(political_orientation, 4, 7) & high_education == "high" ~ "center high",
        political_orientation > 7 & high_education == "high" ~ "right high",
        TRUE ~ "not so high"
      )
  )

gp_covid %>% 
  select(political_orientation, high_education, pol_leaning_edu) %>% 
  sample_n(5)
```

---

## `dplyr::case_when()`

A few things to note about `case_when()`:
- you can have multiple conditions per value
- conditions are evaluated consecutively
- when none of the specified conditions are met for an observation, by default, the new variable will have a missing value `NA` for that case
- if you want some other value in the new variables when the specified conditions are not met, you need to add `TRUE ~ value` as the last argument of the `case_when()` call
- to explore the full range of options for `case_when()` check out its [online documentation](https://dplyr.tidyverse.org/reference/case_when.html) or run `?case_when()` in `R`/*RStudio*

---

## `dplyr::case_when()`

```{r, case-when-cartoon, out.width = "95%", echo = F}
include_picture("dplyr_case_when.png")
```
<small><small>Artwork by [Allison Horst](https://github.com/allisonhorst/stats-illustrations)</small></small>

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_2_2_2_Define_your_Cases.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/solutions/Exercise_2_2_2_Define_your_Cases.html)

---

## Get a bit more programmy

So far, all of the previous tasks share two characteristics
- based on the structure of the whole dataset
- the output is again the whole dataset

Particularly in data analysis, our aim is often to extract information from a dataset (e.g., summary statistics, regression estimates). We now will learn a bit more about
- writing functions
- if-else loops
- for loops and the like
- modern `tidyverse` implementations

---

## Functional Programming: In `R`, everything's a function (more or less)

So you might already be familiar with using functions in `R` (at least we have used them heavily on the previous slides). Functions are applied as shown here:

```{r fancy-function, eval = FALSE}
fancy_function(data)
```

They can be nested, for example:

```{r nested-functions}
log(sum(c(1, 2, 3)))
```

---

## Defining your own function is straightforward

First, let's create a simple function that adds `1` to an entered number.

```{r own-function}
add_one <- function (a_number) {
  a_number + 1
}
```

Now, we can simply apply it to some data as in any other `R` function.

```{r function-applied}
add_one(2)
add_one(99)
```

---

## Extend the sum function

```{r sum-na}
sum_na <- function (x) {
  sum(x, na.rm = TRUE)
}
```

---

## Feed it into `mutate()` and `across()`

```{r sum-na-across}
gp_covid <- 
  gp_covid %>% 
  rowwise() %>%
  mutate(
    new_sum_trust = 
      sum_na(c_across(hzcy044a:hzcy052a))
  ) %>% 
  ungroup()

gp_covid %>% 
  select(hzcy044a:hzcy052a, new_sum_trust) %>% 
  glimpse()
```

---

## if-else architecture in `R`

Using if-else statements in `R` requires at least 3 steps:
1. Starting the loop with `if()`
2. Add the condition to be tested in the parentheses of the `if(condition)`
3. Write a function or procedure on data in the curly brackets of the `if(condition){ ... }`

For example:

```{r simple-if}
if (1 < 2) {
  1 + 2
}
```

---

## Adding else statements
In a fourth step, we can add an `else { ... }`

```{r simple-if-else}
if (1 > 2) {
  1 + 2
} else {
  2 + 5
}
```

So, the general architecture is like this:
```{r eval = FALSE}
if (condition) {
  function_to_apply(data)
} else {
  other_function_to_apply(data)
}
```

(We could also test for another condition in the else statements with `else if()`)

---

## Adding it to our function!

```{r descriptives-na}
descriptives_na <- function(x, statistic) {
  if (statistic == "sum") {
    sum(x, na.rm = TRUE)
  } else if (statistic == "mean") {
    mean(x, na.rm = TRUE)
  } else {
    stop("no valid statistic provided!")
  }
}
```

---

## Trying it out

```{r descriptives-na-sum}
descriptives_na(c(1, 2), statistic = "sum")
```

```{r descriptives-na-mean}
descriptives_na(c(1, 2), statistic = "mean")
```

```{r descriptives-na-mode, error = TRUE}
descriptives_na(c(1, 2), statistic = "mode")
```

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_2_2_3_If_I_had_a_Function.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_2_2_4_If_I_had_a_Function.html)

---

## `for()` loops
(Simple) loops using the `for()` function are some of the most useful tools in functional programming.

They, e.g., enable iterating through input data and applying functions to each element of the data
- it depends on the specific purpose what defines this element
  - the elements can be rows, columns, list elements, etc.
- hence, it is crucial to think about the iterator of the specific call

---

## Architecture of for-loops

```{r eval = FALSE}
for (iterator_name in data) {
  function_to_apply(iterator_name)
}
```

---

## Calculating means of all trust variables

```{r trust-means}
variables_vector <- 
  c(
    "hzcy044a", "hzcy044a", "hzcy044a", "hzcy047a", "hzcy048a",
    "hzcy049a", "hzcy050a", "hzcy051a", "hzcy052a"
  )


for (variable in variables_vector) {
  print(
    descriptives_na(
      gp_covid[[variable]], 
      statistic = "mean"
    )
  )
}
```

---

## The apply family
The apply family is aimed to make your life a bit easier when writing `base R` loops.
- provides a friendly interface to enter your data
- data come out in a standard format
- it may be faster than, e.g., writing a `for()` loop

However, we won't cover all functions of this precious family
- **`apply()`**
- **`lapply()`**
- **`sapply()`**
- **`tapply()`**
- `mapply()`, `rapply()`, & `vapply()` are left out

---

## apply()
The `apply()` function is useful when you want to fire up a short command across either all columns (option `MARGIN = 2`) _or_ rows (option `MARGIN = 1`).

```{r apply}
# means across columns/variables
apply(gp_covid[,20:24], 2, function (x) descriptives_na(x, statistic = "mean"))

# means across rows/observations
apply(gp_covid[1:10,20:24], 1, function (x) descriptives_na(x, statistic = "mean"))
```

While there are plenty of functions for building descriptive tables already out there (e.g., `psych::describe` ), this becomes handy when you want to create them yourself.

---

## lapply()
`lapply()` is for more elaborated operations. However, there are no `MARGIN` options, so let's see what happens when we use similar to what we did before:

```{r lapply_error}
lapply(gp_covid[,20:24], function (x) descriptives_na(x, statistic = "mean"))
```

---

## lapply() returns lists

It might be a little bit uncomfortable, but `lapply()` returns each result of an iterated operation as a list element. Thus, the output of applying the function is a list. 

Some people don't like lists as they separate information from each other.

I like lists.

---

## sapply()

`sapply()` is similar to `lapply()`. The minor but significant difference is that it returns vectors instead of lists. When you want to add the results of this function as a new column to your existing data, this comes in handy.

```{r sapply}
sapply(gp_covid[,20:24], function (x) descriptives_na(x, statistic = "mean"))
```

---

## tapply()
Finally, `tapply()` is useful when you want to perform an action across different groups in your data.

```{r tapply}
tapply(
  gp_covid$political_orientation, 
  gp_covid$sex,
  function (x) descriptives_na(x, statistic = "mean")
  )
```

---

## Modern stuff from the `tidyverse`'s `purrr` package

.pull-left[
Thus far, our examples have not been that complicated
- we had one specific task to perform and the input data were not complex
]

.pull-right[
Sometimes, things are a bit more complicated
- the data have to be wrangled before the actual loop
]

.pull-left[
```{r purrr-logo, echo = FALSE, out.width = "50%"}
woRkshoptools::include_picture("purrr_logo.png")
```
]

.pull-right[
**`purrr` provides a collection of functions that also integrate nicely into a
`%>%` workflow.** 
]

---

## A simple `map()` example

```{r map}
library(purrr)

gp_covid %>% 
  select(sex, hzcy044a:hzcy052a) %>% 
  group_by(sex) %>% 
  group_split(sex, .keep = FALSE) %>% 
  map(~as.matrix(.x)) %>% 
  map_dbl(~descriptives_na(.x, statistic = "mean"))
```

---

## `purrr::map()`

A few things to note about `map()`:
- `map()` usually expects a list as input
  - this is why we split our data into two lists
- a function is applied to each list element with a preceding `~` operator
- per default, `map()` returns the results also as a list
  - yet, there are pre-defined `map()`-flavors that return other data types (e.g.,  the used `map_dbl()`)
  - you may want to have a look at the help page using `?map` for a comprehensive overview
  
**We will re-use the `purrr` capabilities later this week when we wrangle multiple regression models at the same time.**

---

## `purrr::map()`

```{r, map-cartoon, out.width = "95%", echo = F}
include_picture("map_frosting.png")
```
<small><small>Artwork by [Allison Horst](https://github.com/allisonhorst/stats-illustrations)</small></small>

---

## Overview to the looping functions

| Name           | For what?                                | belongs to  |
|----------------|------------------------------------------|-------------|
| `for()`        | raw interface to repeated tasks          | `base R`    |
| `apply()` etc. | convenience functions for repeated tasks | `base R`    |
| `map()` etc.   | integrates into `%>%` workflow           | `Tidyverse` |
| ...            | ...                                      | ...         |
| `while()`      | do something as long condition is met    | `base R`    |

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2021/exercises/Exercise_2_2_4_Purrr_Joy_of_Writing_Loops.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2021/solutions/Exercise_2_2_4_Purrr_Joy_of_Writing_Loops.html)

---

# Extracurricular activities
`R` can also be used for creating text-based adventure games. Play the fun short text adventure ["Castle of R"](https://github.com/gsimchoni/CastleOfR) which was designed to test your programming skills using `base R`.

Also check out the [background](http://giorasimchoni.com/2017/09/10/2017-09-10-you-re-in-a-room-the-castleofr-package/) of the programming of the game/package.

