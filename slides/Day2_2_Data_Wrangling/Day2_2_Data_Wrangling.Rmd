---
title: "Introduction to R for Data Analysis"
subtitle: "Data Wrangling"
author: "Johannes Breuer<br />Stefan Jünger"
date: "2020-08-04"
location: "GESIS Summer School in Survey Methodology"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "default-fonts", "../workshop.css"]
    nature:
      highlightStyle: "github"
      highlightLines: true
      countIncrementalSlides: false
---
layout: true

```{r setup, include = F}
if (!require(easypackages)) install.packages("easypackages")
library(easypackages)

packages("rmarkdown", "knitr", "kableExtra", "gadenbuie/xaringanExtra", "hadley/emo", prompt = F)

options(htmltools.dir.version = FALSE)

opts_chunk$set(echo = TRUE, fig.align = "center")

xaringanExtra::use_xaringan_extra(c("tile_view", "clipboard"))
xaringanExtra::use_extra_styles(hover_code_line = TRUE,
                                mute_unhighlighted_code = FALSE)
```

<div class="my-footer">
  <div style="float: left;"><span>`r gsub("<br />", ", ", gsub("<br /><br />|<a.+$", "", metadata$author))`</span></div>
  <div style="float: right;"><span>`r metadata$location`, `r metadata$date`</span></div>
  <div style="text-align: center;"><span>`r gsub(".+<br />", " ", metadata$subtitle)`</span></div>
</div>

<style type="text/css">

pre {
  font-size: 10px
}
</style>

---

## Data wrangling `r ji("cowboy_hat_face")`

Data wrangling is the process of "getting the data into shape", so that you can then explore and analyze them.

Common data wrangling steps when working with tabular data in the social & behavioral sciences include:
- renaming variables
- identifying and (re-)coding missing values
- recoding variables/values
- computing new variables
- reducing a dataset by selecting a subset of variables and/or cases

---

## Data wrangling `r ji("cowboy_hat_face")`

```{r, wrangling-cartoon, out.width = "95%", echo = F}
include_graphics("./pics/data_cowboy.png")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## Data wrangling `r ji("cowboy_hat_face")`

.large[The (in)famous **80/20-rule**: 80% wrangling, 20% analysis]<sup>1</sup>  
  
> Given almost every data task, you’ll almost certainly need to .highlight[clean your data, visualize it, and do some exploratory data analysis] Moreover, .highlight[they are also important as you move into more advanced topics.] Do you want to start doing machine learning, artificial intelligence, and deep learning? You had better know how to clean and explore a dataset. If you can’t, you’ll basically be lost ([Sharp Sight Labs, 2017](https://www.sharpsightlabs.com/blog/first-step-data-science-top-performer/)).

.footnote[
[1] Of course, this ratio relates to the time the working time of the analyst, not computing time.
]  

---

## `Base R` vs. `tidyverse`

While data wrangling can be done with `base R`, packages from the [`tidyverse`](https://www.tidyverse.org/) can facilitate this process, especially for `R` novices.

Similar to other fierce academic debates over, e.g., `R` vs. `Python` or Frequentism vs. Bayesianism, people have argued [for](http://varianceexplained.org/r/teach-tidyverse/) and [against](https://blog.ephorie.de/why-i-dont-use-the-tidyverse) using/teaching the `tidyverse`.

Our personal experience with teaching the `tidyverse` is something like this...

.center[<img src="./pics/tidyverse_meme.png" width="50%">]
<small><small>Source: https://s.unhb.de/ReoyN</small></small>

---

## `data.table`

Another option for data wrangling with `R` is the [`data.table` package](https://rdatatable.gitlab.io/data.table/index.html). The reason we do not discuss `data.table` in this course is that neither of us has extensive experience with it and comparing all three options (`base R`, `tidyverse`, and `data.table`) side-by-side would be enough for a separate workshop/course.

There is, however, a very detailed [blog post by Jason Mercer](https://wetlandscapes.com/blog/a-comparison-of-r-dialects/) that compares the functionalities of `base R`, `tidyverse`, and `data.table` for data wrangling and [another one by Atreba](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/) that focuses on a comparison between `data.table` and [`dplyr`](https://dplyr.tidyverse.org/) which is a key package for data manipulation from the `tidyverse`. 

---

## Structure & focus of this session

For most of the data wrangling tasks we discuss in this section, we will show how do do them with `base R` and the `tidyverse`, so that you can get a sense of the differences.

Our main focus, however, will be on the use of packages (and functions) from the `tidyverse` and how they can be used to clean and transform your data.

Of course, it is possible to combine `base R` and `tidyverse` code (confession: and I still frequently do that). However, in the long run, you should try to aim for consistency.

---

## What is the `tidyverse`?

> The `tidyverse` is an .highlight[opinionated collection of R packages designed for data science]. All packages share an .highlight[underlying design philosophy, grammar, and data structures] ([Tidyverse website](https://www.tidyverse.org/)).

> The `tidyverse` is a .highlight[coherent system of packages for data manipulation, exploration and visualization] that share a .highlight[common design philosophy] ([Rickert, 2017](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/)).

```{r tidyverse-hex, out.width = "25%", echo = F}
include_graphics("./pics/hex-tidyverse.png")
```

---

## Benefits of the `tidyverse`

As stated before, data wrangling can also be done with `base R`. However, the syntax for this is typically (more) verbose and not intuitive and, hence, difficult to learn, remember, and read (plus many `tidyverse` operations are faster than their `base R` equivalents).  
  
`Tidyverse` syntax is designed to increase **human-readability**. This makes it especially **attractive for R novices** as it can facilitate the experience of **self-efficacy** (see [Robinson, 2017](http://varianceexplained.org/r/teach-tidyverse/)). The `tidyverse` also aims for **consistency** (e.g., data frame as first argument and output) and uses **smarter defaults** (e.g., no partial matching of data frame and column names).

*Note*: If you want to learn more about data wrangling with the `tidyverse` through fun projects, you should check out [Tidy Tuesday](https://github.com/rfordatascience/tidytuesday) and the associated [#tidytuesday Twitter hashtag](https://twitter.com/hashtag/tidytuesday?lang=en).

---

# (IMHO minor) Downsides of using the `tidyverse`

The `tidyverse` is a collection of packages with quite a few dependencies. Hence, installing it can take time if you [cannot use binary packages and need to install from source](http://r-pkgs.had.co.nz/package.html#package) (e.g., on a *Linux* system or if you install development versions from *GitHub*). To avoid this (plus potential namespace conflicts), a good solution is installing and loading `tidyverse` packages individually.

The `tidyverse` is being continuously developed by a big team of people. This means that, unlike for `base R` functions, there can be major changes to how stuff works. Two recent examples are the [change from `spread()` and `gather()` to `pivot_longer()` and `pivot_wider()`](https://www.tidyverse.org/blog/2019/09/tidyr-1-0-0/#pivoting) and the [replacement of scoped variants of some `dplyr` functions with the `across()` function](https://dplyr.tidyverse.org/reference/across.html). However, `tidyverse` developers generally make sure that there is backwards compatibility with previous versions (so that superseded functions can still be used; although this typically leads to warnings being displayed and this backwards compatibility may end some time with some future version). 

---

## Lift-off into the `tidyverse` `r ji("rocket")`
**Install all `tidyverse` packages** (for the full list of `tidyverse` packages see [https://www.tidyverse.org/packages/](https://www.tidyverse.org/packages/))
```{r install-tidyverse, eval = F, echo = T}
install.packages("tidyverse")

```
**Load core `tidyverse` packages** (NB: To save time and reduce namespace conflicts it can make sense to load the `tidyverse` packages individually)
```{r load-tidyverse, eval = T, echo = T, message = T}
library("tidyverse")

```

---

## `tidyverse` vocabulary 101

While there is much more to the `tidyverse` than this, three important concepts that you need to be familiar with, if you want to use it, are:

1. pipes

2. tibbles

3. tidy data

We discussed pipes and tibbles in the session on *Programming in `R`*, so we'll only (very briefly) talk about *tidy data* here.

---

## Tidy data

The 3 rules of tidy data:

1. Each **variable** is in a separate **column**.

2. Each **observation** is in a separate **row**.

3. Each **value** is in a separate **cell**.

<img src="pics/tidy_data.png" width="100%">
Source: https://r4ds.had.co.nz/tidy-data.html

*NB*: In the `tidyverse` terminology 'tidy data' often also means data in long format - where applicable. 

---

## Wide vs. long format

<img src="pics/wide-long.png" width="90%">
Source: https://github.com/gadenbuie/tidyexplain#tidy-data

---

# Wide vs. long format

The easiest way to switch from wide to long format and vice versa are the functions `pivot_longer()` and `pivot_wider()` from the [`tidyr` package](https://tidyr.tidyverse.org/).

---

## Dataset

For the examples and exercises in this session we will, again, use data from the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* and some of the data from *Gapminder*.

Remember that to code along and for the exercises the *GESIS Panel* files should be in a folder called `data` in the same folder as the other materials for this course.

---

## Interlude: Citing data

If you (re-)use existing datasets, please cite them in your publications, theses, teaching materials, etc. Data repositories normally provide information on how to cite the data. For example, the APA-style citation for *Public Use File (PUF) of the GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* is:

GESIS Panel Team (2020). GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany. *GESIS Datenarchiv, Köln. ZA5667 Datenfile Version 1.1.0*, https://doi.org/10.4232/1.13520.

---

## Interlude: Citing FOSS

You should also make sure to cite the free and open-source software that you use, such as `R` packages and `R` itself. There is a function in `R` that tells you how to cite it or any of the packages you have installed.

.small[
```{r citation}
citation()
```
]
---

## Interlude: Citing FOSS

.small[
```{r pkg-citation}
citation("tidyverse")
```
]

There even is an `R` package called [`grateful`](https://github.com/Pakillo/grateful) that automatically generates a document with references for all `R` packages that have been used for a given project

---

## Codebook

It is always advisable to consult the codebook (if there is one) before starting to work with a(n existing) dataset. The *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* comes with a very [detailed codebook](https://dbk.gesis.org/dbksearch/download.asp?id=67378).

Side note: If you want to (semi-)automatically generate a codebook for your own dataset, there are several options in `R`:

- The [`codebook` package](https://github.com/rubenarslan/codebook) which includes an *RStudio*-Addin and also offers a [web app](https://rubenarslan.ocpu.io/codebook/www/)

- the `makeCodebook()` function from the [`dataMaid` package](https://github.com/ekstroem/dataMaid) (see this [blog post](http://sandsynligvis.dk/articles/18/codebook.html) for a short tutorial)

- the `codebook()` function from the [`memisc` package](https://github.com/melff/memisc)

---

## Load the data

The first step, of course, is loading the data into `R`. The *Public Use File (PUF) of the GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* is available in different formats. We will work with the `.csv` file.

```{r load-gesis-panel-data-display, eval = F}
gesis_panel_corona <- read_csv2("./data/ZA5667_v1-1-0.csv")
```

```{r load-gesis-panel-data, echo = F}
gesis_panel_corona <- read_csv2("../../data/ZA5667_v1-1-0.csv")
```

---

## Note: Tidy vs. untidy data

As a lot of work (by many people) has already gone into this dataset, the *Public Use File (PUF) of the GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* is already tidy. Notably, if you collect data yourself, this may not be the case (at least at the beginning). For example, cells may hold more than one value or a variable that should be in one column is spread across multiple columns (e.g., parts of a date or name).

If you need to make your data tidy or change it from wide to long format or vice versa (which may, e.g., be necessary if you work with longitudinal survey data from multiple waves), the [`tidyr` package](https://tidyr.tidyverse.org/) from the `tidyverse` is a good option. There are many introductions and tutorials for tidying data available online and we also covered this in our section on *Tidy Data*  in the workshop on [*Data Wrangling & Exploration with the Tidyverse in R*](https://github.com/jobreu/tidyverse-workshop-gesis-2019) that we gave in 2019.

---

## Dataframe check 1, 2, 1, 2!

Even before checking the codebook for a dataset (if there is one) it always helps to have a quick look at the data. The most high-level information you can get is about the object type and its dimensions.

.small[
```{r class-dim}
# object type
class(gesis_panel_corona)

# number of rows and columns
dim(gesis_panel_corona)

# number of rows
nrow(gesis_panel_corona)

# number of columns
ncol(gesis_panel_corona)
```
]

---

## Dataframe check 1, 2, 1, 2!

You can also print the first 6 lines of the dataframe with `head()`. You can easily change the number of lines by providing the number as the second argument to the `head()` function.

```{r head, eval = F}
head(gesis_panel_corona, 10)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "head", echo = F}
```
]

---

## Dataframe check 1, 2, 1, 2!

If we want some more (detailed) information about the dataset, we can use the `base R` function `str()`.

```{r str, eval = F}
str(gesis_panel_corona)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "str", echo = F}
```
]

---

## Dataframe check 1, 2, 1, 2!

As you saw on the previous slide, the output of `str()` can be a bit hard to read (especially for larger datasets). A good alternative that creates a more clearly laid output is the `glimpse()` function from the `dplyr` package.

```{r glimpse, eval = F}
glimpse(gesis_panel_corona)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "glimpse", echo = F}
```
]

---

## Dataframe check 1, 2, 1, 2!

If you want to have a look at your full dataset, you can use the `View()` function. In *RStudio*, this will open a new tab in the source pane through which you can explore the dataset (including a search function). You can also click on the small spreadsheet symbol on the right side of the object in the environment tab to open this view. 

```{r view, eval = F}
View(gesis_panel_corona)
```

```{r, view-pic, out.width = "70%", echo = F}
include_graphics("./pics/rstudio_view.png")
```

---

## What's in a name?

One thing that we need to know - and might want to change - are the names of the variables in the dataset.

```{r names-gpc, eval = F}
names(gesis_panel_corona)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "names-gpc", echo = F}
```
]

---

## What's in a name?

As you can see, only a few of the variable names in the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* dataset are descriptive. The names have meaning as they are composed of codes representing the study wave, study name, variable number and whether they are original or derived variables (have a look at the [*GESIS Panel* cheatsheet](https://www.gesis.org/fileadmin/upload/forschung/programme_projekte/Drittmittelprojekte/GESIS_Panel/gesis_panel_cheatsheet.pdf) if you want to know more), but they are not intuitive to understand. Hence, for analyzing them, especially if you want to create tables and/or plots, it can make sense to rename them. This is also a common step if you work with your own data. Depending on what method or tool(s) you used to collect the data, the variable names may also not be what you want or need them to be.

---

## Renaming variables/columns

It good practice to use consistent naming conventions. Since `R` is case-sensitive, we might, e.g., want to only use lowercase letters. As spaces in variable names can cause problems, we could, e.g., decide to use `r ji("snake")` *snake_case* (`r ji("camel")` *camelCase* is a common alternative; for a good brief discussion of options for avoiding spaces in variable names, see this [Medium post by Patrick Divine](https://medium.com/@pddivine/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841)).

*Note*: The [`janitor` package](https://github.com/sfirke/janitor) (which is `tidyverse`-oriented) can be used to facilitate several common data cleaning tasks. Among other things, it contains the function `clean_names()` that takes a dataframe and creates column "names are unique and consist only of the _ character, numbers, and letters" (from the help file for this function), with the default being `r ji("snake")` snake_case (but support for many other types of cases).  

---

# Become an ace of case

```{r, case-cartoon, out.width = "90%", echo = F}
include_graphics("./pics/coding_cases.png")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## `dplyr`

The `tidyverse` examples in the following will make use of functions from the [`dplyr` package](https://dplyr.tidyverse.org/).

- `dplyr` functions are verbs that signal an action  

- the first argument is a dataframe (or tibble)  

- the output normally also are dataframes (tibbles) 

- columns (= variables in a tidy dataframe) can be referenced without quotation marks (non-standard evaluation)

---

## Renaming variables/columns

To choose meaningful variable names, we need to look at the codebook. Say, for example, we want to rename the variables representing the responses to the questions asking whether people use *Facebook* or other social media to get information about the Coronavirus.

.small[
```{r rename-vars, eval = F}
# Base R
colnames(gesis_panel_corona)[colnames(gesis_panel_corona) == "hzcy090a"] <- "corona_inf_facebook"
colnames(gesis_panel_corona)[colnames(gesis_panel_corona) == "hzcy091a"] <- "corona_inf_other_sm"

# tidyverse (dplyr)
gesis_panel_corona <- gesis_panel_corona %>% 
  rename(corona_inf_facebook = hzcy090a, # new_name = old_name
         corona_inf_other_sm = hzcy091a)

```
]

---

## Selecting columns/variables

In many cases, we do not need all the variables in a dataset for our analyses. In the following example, we use two options from `base R` to select the variables from the *GESIS Panel* dataset relating to the self-assessed risk of becoming infected with the Coronavirus.

There are two options for doing this with `base R`:

Option 1
.small[
```{r select-vars-base}
corona_risk <- gesis_panel_corona[, c("hzcy001a", "hzcy002a", "hzcy003a", "hzcy004a", "hzcy005a")]
# When subsetting with [], the first value refers to rows, the second to columns
# [, c("var1", "var2", ...)] means we want to select all rows but only some specific columns.
```
]

Option 2
.small[
```{r subset}
corona_risk  <- subset(gesis_panel_corona, TRUE, select = c(hzcy001a, hzcy002a, hzcy003a, hzcy004a, hzcy005a))
# Again, here the 2nd argument refers to the rows.
# Setting it to TRUE means that we want to include all rows in the subset.
```
]

---

## Selecting columns/variables

In the `tidyverse`, we can create a subset of variables with the `dplyr` verb `select()`.

```{r select}
corona_risk <- gesis_panel_corona %>% 
  select(hzcy001a,
         hzcy002a,
         hzcy003a,
         hzcy004a,
         hzcy005a)

head(corona_risk)
```

---

## Selecting a range of columns/variables

There also is a shorthand notation for selecting a set of consecutive columns with `select()`.

```{r select-range}
corona_risk <- gesis_panel_corona %>% 
  select(hzcy001a:hzcy005a)

head(corona_risk)
```

---

## Re~~wind~~name selecta

A nice thing about the `dplyr` verb `select` is that you can use it to select and rename variables in one step.

.small[
```{r select-rename}
corona_risk <- gesis_panel_corona %>% 
  select(risk_self = hzcy001a,
         risk_surroundings = hzcy002a,
         risk_hospital = hzcy003a,
         risk_quarantine = hzcy004a,
         risk_infect_others = hzcy005a)

head(corona_risk)
```
]

---

## Unselecting columns/variables

If you just want to exclude one or a few columns/variables, it is easier to unselect those than to select all others. Again, there's two ways to do this with `base R`.

Option 1
.small[
```{r unselect-base}
gesis_panel_corona_cut <- gesis_panel_corona[!(names(gesis_panel_corona) %in% c("za_number", "version", "doi"))]
# The %in% operator means "is included in" (in this case the following character vector)

dim(gesis_panel_corona_cut)
```
]

Option 2
.small[
```{r subset-unselect}
gesis_panel_corona_cut <- subset(gesis_panel_corona, TRUE, select = -c(za_number, version, doi))

dim(gesis_panel_corona_cut)
```
]

---

## Unselecting columns/variables

`select()` from `dplyr` also allows you to easily exclude one or more columns/variables.

```{r select-unselect, eval = F}
gesis_panel_corona_cut <- gesis_panel_corona %>% 
  select(-(za_number:doi))

glimpse(gesis_panel_corona_cut)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "select-unselect", echo = F}
```
]

---

## Advanced ways of selecting columns/variables

Sometimes the ways of selecting columns/variables shown on the previous slides might be difficult or tedious to use, especially if you have datasets with a large number of variables in them.  

Fortunately, there are many so-called helper functions and scoped variants for the `dplyr` `select()` function. We will explore two of those options in the following. For a more exhaustive overview you can have a look at the [tutorial by Suzan Baert](https://suzan.rbind.io/2018/01/dplyr-tutorial-1/).

---

## Select columns/variables based on parts their names

```{r select-name-parts}
gesis_panel_corona_cy <- gesis_panel_corona %>% 
  select(starts_with("hzcy"))

gesis_panel_corona_cat <- gesis_panel_corona %>% 
  select(ends_with("_cat"))

glimpse(gesis_panel_corona_cat)
```

---

## Select columns/variables based on their type

```{r select-type, eval = F}
# Only keep numeric variables from the dataset
gesis_panel_corona_num <- gesis_panel_corona %>% 
  select_if(is.numeric)

glimpse(gesis_panel_corona_num)
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

.smaller[
```{r ref.label = "select-type", echo = F}
```
]

---

## Moving columns

While the positions of columns in the dataframe do not matter for the analyses or plotting (unless you want to select columns using their numerical index), you might want to change them. For this purpose, `dplyr` provides the `relocate()` function.

```{r relocate, eval = F}
gesis_panel_corona <- gesis_panel_corona %>% 
  relocate(marstat, .after = education_cat)
```

You can also move a column before a specific other column. For this you need to provide a column name to the `.before` argument (instead of `.after`). A quick solution for moving a column to the last position in a dataframe is to use specify the argument `.after = last_col()`.

---

## `dplyr::relocate()`

```{r, relocate-cartoon, out.width = "85%", echo = F}
include_graphics("./pics/dplyr_relocate.png")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## Filtering rows/observations

In `R`, you can filter rows/observations dependent on one or more conditions.

To filter rows/observations you can use... 
- **comparison operators**:
    - **<** (smaller than)
    - **<=** (smaller than or equal to)
    - **==** (equal to)
    - **!=** (not equal to)
    - **>=** (larger than or equal to)
    - **>** (larger than)
    - **%in%** (included in)

... and combine them with
- **logical operators**:
    - **&** (and)
    - **|** (or)
    - **!** (not)
    - **xor** (either or, not both)

---

## Filtering rows/observations

Similar to selecting columns/variables, there are two parallel options for filtering rows/observations with `base R`.

Option 1
```{r filter-base}
gesis_panel_corona_male <- gesis_panel_corona[gesis_panel_corona$sex == 1, ]

dim(gesis_panel_corona_male)
```

Option 2
```{r filter-subset}
gesis_panel_corona_male <- subset(gesis_panel_corona, sex == 1)

dim(gesis_panel_corona_male)
```

---

## Filtering rows/observations

The `tidyverse` solution for filtering rows/observations is the `dplyr` verb `filter()`.

```{r dplyr-filter-1}
gesis_panel_corona_male <- gesis_panel_corona %>% 
  filter(sex == 1)

dim(gesis_panel_corona_male)
```

---

## `dplyr::filter()`

```{r, filter-cartoon, out.width = "95%", echo = F}
include_graphics("./pics/dplyr_filter.jpg")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## Selecting columns + filtering rows

Of course, you can also combine the selection of columns and the filtering of rows.

`Base R` option 1
.small[
```{r colsrows-base}
corona_risk_male <- gesis_panel_corona[gesis_panel_corona$sex == 1, c("hzcy001a", "hzcy002a", "hzcy003a", "hzcy004a", "hzcy005a")]

dim(corona_risk_male)
```
]

`Base R` option 2
.small[
```{r colsrows-subset}
corona_risk_male  <- subset(gesis_panel_corona, sex == 1, select = c(hzcy001a, hzcy002a, hzcy003a, hzcy004a, hzcy005a))

dim(corona_risk_male)
```
]

---

## Selecting columns + filtering rows

The `tidyverse` approach to combining the selection of columns and the filtering of rows is to chain these steps together in a pipe (in this case, the order of the pipe steps does not matter).

```{r dplyr-select-filter}
corona_risk_male <- gesis_panel_corona %>% 
  filter(sex == 1) %>% 
  select(hzcy001a:hzcy005a)

dim(corona_risk_male)
```

---

## `dplyr::filter` - multiple conditions

Of yourse, you can also filter rows/observations based on more than one condition.

```{r filter-2-ond}
gesis_panel_corona_old_men <- gesis_panel_corona %>% 
  filter(sex == 1, age_cat > 7)

dim(gesis_panel_corona_old_men)
```

---

## `dplyr::filter` - multiple conditions

By default, multiple conditions in `filter()` are added as & (and). You can, however, also specify multiple conditions differently.

**or** (cases for which at least one of the conditions is true)

```{r filter-or}
gesis_panel_corona_old_andor_male <- gesis_panel_corona %>% 
  filter(sex == 1 |
           age_cat > 7)
```

**xor** (cases for which only one of the two conditions is true)

```{r filter-xor}
gesis_panel_corona_old_or_male <- gesis_panel_corona %>%
  filter(xor(sex == 1, 
             age_cat > 7))
```

---

## Advanced ways of filtering observations

Similar to the basic options for `select()`, the basic variants of `filter()` might not meet your needs when it comes to more specific or complicated ways of data wrangling.  

Again, there are several helper functions and scoped variants of the `filter()` function that can help you (and there also is a detailed [tutorial by Suzan Baert](https://suzan.rbind.io/2018/02/dplyr-tutorial-3/) on this). We will show two of those in the following.

---

## Filter rows based on a range in a numeric variable

```{r filter-between}
gesis_panel_corona_rightwing <- gesis_panel_corona %>% 
  filter(between(political_orientation, 8, 10))

dim(gesis_panel_corona_rightwing)
```

Note that the range specified in `between()` is inclusive.

---

## Filter based on a selection of variables

```{r filter-at}
# Select all cases where at least one of the specified variables is > 0
gesis_panel_corona_measures_taken <- gesis_panel_corona %>% 
    filter_at(vars(hzcy006a:hzcy016a),
    any_vars(. > 0))

dim(gesis_panel_corona_measures_taken)
```

---

## Sorting a dataframe by a single variable

Again, while this does not directly matter for analyses or plotting (unless you want to filter rows by their numeric index), you can rearrange the order of rows in a dataset.

```{r sort-1-var, eval = F}
# Base R
gesis_panel_corona[order(gesis_panel_corona$political_orientation),]

# Tidyverse
gesis_panel_corona %>% 
  arrange(political_orientation)
```

---

## Sorting a dataframe by a single variable

Of course, it is also possible to sort a dataframe in descending order of a variable.

```{r sort-1-var-desc, eval = F}
# Base R
gesis_panel_corona[order(desc(gesis_panel_corona$political_orientation)),]

# Tidyverse
gesis_panel_corona %>% 
  arrange(desc(political_orientation))
```

*Note*: You can also use `-` instead of `desc()`, if you sort by numeric variables.

---

## Sorting a dataframe by a multiple variables

You can also sort your dataframe by more than one variable.

.small[
```{r sort mult vars, eval = F}
# Base R
gesis_panel_corona[order(gesis_panel_corona$political_orientation, gesis_panel_corona$education_cat),]

# Tidyverse
gesis_panel_corona %>% 
  arrange(political_orientation, education_cat)
```
]

---

## Missing values

Most of the real datasets we work with have missing data. As the data can be missing for various reasons, we often use codes (and labels) to distinguish between different types of missing data.

If you look at the the [codebook](https://dbk.gesis.org/dbksearch/download.asp?id=67378) of the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* or the [*GESIS Panel* Cheatsheet](https://www.gesis.org/fileadmin/upload/forschung/programme_projekte/Drittmittelprojekte/GESIS_Panel/gesis_panel_cheatsheet.pdf), you will see that there are quite a few types of and codes for missing data.

---

## Missing values

In `R`, missing values are represented by `NA`. `NA` is a reserved term in `R`, meaning that you cannot use it as a name for anything else (this is also the case for `TRUE` and `FALSE`).

When we prepare our data for analysis there are generally two things we might want/have to do with regard to missing values:

- define specific values as missings (i.e., set them to `NA`)

- recode `NA` values into something else (typically to distinguish between different types of missing values)

---

## Types of missing values

If you look through the [codebook](https://dbk.gesis.org/dbksearch/download.asp?id=67378) of the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany*, you will notice that some types of missing values are the same across variables, while some variables also have additional types of missing data (and, hence, additional codes for missings).

To make things easier for the following examples, we will select a subset of variables.

```{r gpc-measures-subset}
gesis_panel_corona_measures <- gesis_panel_corona %>% 
  select(hzcy006a:hzcy016a)
```

---

## Recode values as `NA`

With `base R` you can set values to `NA` for specific variables as follows:

.small[
```{r set-NA-var-base}
sum(is.na(gesis_panel_corona_measures$hzcy006a))

gesis_panel_corona_measures$hzcy006a[gesis_panel_corona_measures$hzcy006a == -99] <- NA
gesis_panel_corona_measures$hzcy006a[gesis_panel_corona_measures$hzcy006a == -77] <- NA
gesis_panel_corona_measures$hzcy006a[gesis_panel_corona_measures$hzcy006a == -33] <- NA
gesis_panel_corona_measures$hzcy006a[gesis_panel_corona_measures$hzcy006a == -22] <- NA
gesis_panel_corona_measures$hzcy007a[gesis_panel_corona_measures$hzcy007a == -99] <- NA
gesis_panel_corona_measures$hzcy007a[gesis_panel_corona_measures$hzcy007a == -77] <- NA
gesis_panel_corona_measures$hzcy007a[gesis_panel_corona_measures$hzcy007a == -33] <- NA
gesis_panel_corona_measures$hzcy007a[gesis_panel_corona_measures$hzcy007a == -22] <- NA

sum(is.na(gesis_panel_corona_measures$hzcy006a))
```
]

---

## Recode values as `NA`

The `tidyverse` option for setting values of individual variables to `NA` is the `na_if()` function combined with the `mutate()`function (which we will discuss in more detail when we talk about transforming variables and creating new ones), both from the `dplyr` package.

```{r na-if}
gesis_panel_corona_measures <- gesis_panel_corona_measures %>% 
  mutate(hzcy006a = na_if(hzcy006a, -99)) %>% 
  mutate(hzcy006a = na_if(hzcy006a, -77)) %>% 
  mutate(hzcy006a = na_if(hzcy006a, -33)) %>% 
  mutate(hzcy006a = na_if(hzcy006a, -22)) %>% 
  mutate(hzcy007a = na_if(hzcy007a, -99)) %>% 
  mutate(hzcy007a = na_if(hzcy007a, -77)) %>% 
  mutate(hzcy007a = na_if(hzcy007a, -33)) %>% 
  mutate(hzcy007a = na_if(hzcy007a, -22)) 
```

---

## Recode values as `NA`

Of course, setting values to `NA` for individual variables can become quite tedious if there are a lot of variables and missing value codes.

If the missing values are the same for the whole dataframe, a quick solution is to use `mutate_all()` which is a scoped variant of `mutate()` from the `dplyr` package (again, we will talk about these functions in more depth later):

```{r mutate-all-na-if}
sum(is.na(gesis_panel_corona_measures$hzcy008a))

gesis_panel_corona_measures <- gesis_panel_corona_measures %>%
  mutate_all(list(~na_if(., -99))) %>% 
  mutate_all(list(~na_if(., -77))) %>% 
  mutate_all(list(~na_if(., -33))) %>% 
  mutate_all(list(~na_if(., -22)))

sum(is.na(gesis_panel_corona_measures$hzcy008a))
```

---

## The missings of `naniar` `r ji("lion")`

A good option for wrangling (and exploring) missing data is the [`naniar` package](http://naniar.njtierney.com/index.html). For example, if you want to replace specific values with `NA` in all variables in your dataframe:

```{r naniar-replace-with-NA-all}
library(naniar)

missings <- c(-99, -77, -33, -22)

gesis_panel_corona_measures <- gesis_panel_corona_measures %>%
  replace_with_na_all(condition = ~.x %in% missings)
```

---

## Exclude cases with missing values

If you want to exclude observations with missing values for individual variables, you can use `!is.na(variable_name)` with your filtering method of choice.

If you only want to keep complete cases in your dataframe, you can easily do so with both `base R` and the `tidyverse` (in this case a function from the `tidyr` package).

```{r only-complete-cases}
# base R
corona_measures_complete <- na.omit(gesis_panel_corona_measures) 

# tidyverse
corona_measures_complete <- gesis_panel_corona_measures %>% 
  drop_na()

dim(corona_measures_complete)
```

A nice thing about `drop_na()` is that you can also provide variable names as arguments to only filter out cases that have missing values for one or more specific variables (check `?drop_na` for details).

---

## Recode `NA` into something else

An easy option for replacing `NA` with another value for a single variable is the `replace_na()` function from the `tidyr` package (in combination with `mutate()` from `dplyr`). Using the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* subset for which we have previously defined all relevant values as `NA`, we would, for example do the following:

```{r replace-na, eval = F}
gesis_panel_corona_measures <- gesis_panel_corona_measures %>% 
  mutate(hzcy006a = replace_na(hzcy006a, -99))

```

Of course, this particular example does not make much sense. You can, however, specify different values for different types of missing values. To do this, you probably need to make the recoding dependent on other variables. We will later on discuss how this can be done.

---

## Changing columns/variables: Simple transformations

The simplest case of changing a column/variable is a direct transformation of its values. If, for example, after defining values as `NA`, we want to increase the value of the variables in the `gesis_panel_corona_measures` by one, we could do so as follows:

```{r simple-var-transform, eval = F}
# base R
gesis_panel_corona_measures$hzcy006a <- gesis_panel_corona_measures$hzcy006a + 1

# tidyverse
gesis_panel_corona_measures <- gesis_panel_corona_measures %>% 
  mutate(hzcy006a = hzcy006a + 1)
```

---

## `dplyr::mutate`

The `mutate()` function from `dplyr` can be used to transform columns/variables and create new ones. Again, this is a very powerful function for which there also are some helpful scoped variants (we've already seen `mutate_all()`). We will discuss some of the many options for using `mutate()` in the following, but for a larger overview you can, e.g., check out the [column transformation tutorial by Suzan Baert](https://suzan.rbind.io/2018/02/dplyr-tutorial-2/).

---

## `dplyr::mutate()`

```{r, mutate-cartoon, out.width = "60%", echo = F}
include_graphics("./pics/dplyr_mutate.png")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## Changing columns/variables: Recoding values

Very often we want/need to recode values in a variable (e.g., if we have reverse-scored items as part of a scale). Say, for example, you want to recode the item from the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* that measures trust in scientists with regard to dealing with the Coronavirus to represent distrust. In `base R`, you can use the same method as for defining a value as `NA` (which we showed you before). Another handy option is the `recode()` function from `dplyr` (again, in combination with `mutate()`).

```{r recode, eval = F}
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(hzcy052aR = recode(hzcy052a,
                           `5` = 1, # `old value` = new value
                           `4` = 2,
                           `2` = 4,
                           `1` = 5))
```

---

## Creating new columns/variables

If you want to add a columnn/variable to a dataset that has the same value for all rows (e.g., to indicate the wave nr. of a longitudinal survey study), you can do so as follows:

```{r add-col-with-same-value, eval = F}
# base R
gesis_panel_corona$wave <- 1

# tidyverse
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(wave = 1)
```

---

## Creating new columns/variables

Usually, however, we want to create new columns/variables based on the values of existing ones. Again, a straightforward way of doing this is `mutate()` plus `recode()`. Using the same example as before:

```{r recode-new-var, eval = F}
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(distrust_scientists = recode(hzcy052a,
                                      `5` = 1, # `old value` = new value
                                      `4` = 2,
                                      `2` = 4,
                                      `1` = 5))
```

---

## Aggregate variables

Something we might want to do for our analyses is to create aggregate variables, such as sum or mean scores for a set of items (that form a scale). If, for example, we want to compute the mean score from the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* items that ask how much people trust specific people or institutions in dealing with the Coronavirus, we might try the following:

.small[
```{r scale-mean-wrong}
corona_trust <- gesis_panel_corona %>% 
  select(hzcy044a:hzcy052a) %>% 
  mutate_all(list(~na_if(., -99))) %>% 
  mutate_all(list(~na_if(., -77))) %>% 
  mutate_all(list(~na_if(., -33))) %>% 
  mutate_all(list(~na_if(., -22))) %>% 
  mutate_all(list(~na_if(., 98))) %>% 
  mutate(mean_trust = mean(c(hzcy044a, #<<
                           hzcy045a, #<<
                           hzcy046a, #<<
                           hzcy047a, #<<
                           hzcy048a, #<<
                           hzcy049a, #<<
                           hzcy050a, #<<
                           hzcy051a, #<<
                           hzcy052a), #<< 
                           na.rm = TRUE)) #<<
# If we don't provide the argument na.rm = TRUE, the new value will be NA, if any value in the variables it is based on is missing.
```
]

---

## Aggregate variables

What went wrong here?

```{r scale-mean-wrong-result}
glimpse(corona_trust)
```

---

## Aggregate variables

The reason the code on the previous slide did not achieve what we (might have) expected is that aggregate functions like `mean()` or `sum()` operate on columns. One solution can be to calculate the mean manually:

.small[
```{r mean-calc}
corona_trust <- corona_trust %>% 
  mutate(mean_trust = (hzcy044a + hzcy045a + hzcy046a + hzcy047a + hzcy048a + hzcy049a + hzcy050a + hzcy051a + hzcy052a)/9)

glimpse(corona_trust)
```

However, the problem here is that some rows have missing values for one or more of the variables, in which case dividing by 9 is not appropriate. Fortunately, `dplyr` offers a better option for row-wise operations: the `rowwise()` function.
]

---

## `dplyr::rowwise`

A better option is the `rowwise()`function which changes how `dplyr` verbs operate on the dataset. If we want a row-wise aggregate for our example dataset, we can use the following code:

.small[
```{r rowwise}
corona_trust <- corona_trust %>%  
  rowwise() %>% 
  mutate(mean_trust = mean(c(hzcy044a,
                           hzcy045a,
                           hzcy046a,
                           hzcy047a,
                           hzcy048a,
                           hzcy049a,
                           hzcy050a,
                           hzcy051a,
                           hzcy052a), 
                           na.rm = TRUE)) %>% 
  ungroup()
```
]

**Note**: We use the `ungroup()` function at the end of this pipe to remove the additional class `rowwise_df` from the dataframe object to ensure that `dplyr` verbs will operate the default way when we further work with the object. We will talk more about grouping and ungrouping in the session on exploratory data analysis.

---

## `dplyr::rowwise`

```{r rowwise-result}
glimpse(corona_trust)
```

*Note*: `NaN` means "not a number" which is [not the same as `NA`](http://onetipperday.sterding.com/2012/08/difference-between-na-and-nan-in-r.html). If you want to change `NaN` to `NA` for this variable, you can, e.g., do so with the `base R` command `corona_trust$mean_trust[is.nan(corona_trust$mean_trust)] <- NA` or with `dplyr`: `corona_trust <- corona_trust %>% mutate(mean_trust = na_if(mean_trust, "NaN"))`.

---

## Create a new variable conditional on values of another one

If you want create to create a new variable (or recode an existing one) and the values depend on the values of another variable in your data, the `case_when()` function from `dplyr` can come in handy.

```{r case-when, eval = F}
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(pol_leaning_cat = case_when(
    between(political_orientation, 0, 3) ~ "left",
    between(political_orientation, 4, 7) ~ "center",
    political_orientation > 7 ~ "right"
    ))
```

A few things to note here:
- conditions are evaluated consecutively
- when none of the specified conditions are met for an observation, the new variable will have a missing value `NA`
- for more information and options check out `?case_when`

---

## `dplyr::case_when()`

```{r, case-when-cartoon, out.width = "95%", echo = F}
include_graphics("./pics/dplyr_case_when.png")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## Factors

Factor are a special type of variable in `R` that represent categorical data. Before `R` version `4.0.0.` the default for `base R` was that all characters variables are imported as factors (remember that `R` was originally developed by and for statisticians).

Internally, factors are stored as integers, but they have (character) labels (so-called *levels*) associated with them. Hence, if you are not working with the special class of labelled data (e.g., via the packages [`haven`](https://haven.tidyverse.org/), [`labelled`](https://larmarange.github.io/labelled/index.html), or [`sjlabelled`](https://strengejacke.github.io/sjlabelled/index.html)), factors come closest to having variables with value labels as you might know from *SPSS*.

Factors in `R` can be **unordered** - in which case they are similar to **nominal** level variables in *SPSS* - or **ordered** - in which case they are similar to **ordinal** level variables in *SPSS*.

Using factors can be necessary for certain statistical analysis and plots (e.g., if you want to compare groups). Working with factors in `R` is a big topic, and we will only briefly touch upon it in this workshop. For a more in-depth discussion of factors in `R` you can, e.g., have a look at the [chapter on factors](https://r4ds.had.co.nz/factors.html) in *R for Data Science* or the [*Software Carpentry* tutorial on factors in `R`](https://swcarpentry.github.io/r-novice-inflammation/12-supp-factors/).  

---

## Factors 4 `r ji("cat")`s 

There are many functions for working with factors in `base R`, such as `factor()` or `as.factor()`. However, a generally more versatile and easier-to-use option is the [`forcats` package](https://forcats.tidyverse.org/) from the `tidyverse`. 

```{r forcats-hex, out.width = "25%", echo = F}
include_graphics("./pics/hex-forcats.png")
```

There is a good [introduction on the `tidyverse` website by Emily Robinson](https://forcats.tidyverse.org/articles/forcats.html) and *RStudio* also offers a [`forcats` cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/factors.pdf).

---

## From numeric to factor

Using the `recode_factor()` function (together with `mutate()`) from `dplyr`, you can create a factor from a numeric (or a character) variable. In the example below, we want an ordered factor.

```{r recode-factor}
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(education_cat = recode_factor(education_cat,
                                       `1` = "Low",
                                       `2` = "Medium",
                                       `3`= "High",
                                       .ordered = TRUE))
```

---

## Creating a factor based on values of another variable

```{r case-when-factor, eval = F}
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(pol_leaning_cat = factor(case_when(
    between(political_orientation, 0, 3) ~ "left",
    between(political_orientation, 4, 7) ~ "center",
    political_orientation > 7 ~ "right")
    ))
```

*Note*: If the factor should be ordered, the `ordered` argument of the `factor()` function should be set to `TRUE`.

---

## Dummy variables

You can combine the `mutate()` function with a simple `ifelse()` statement to create a dummy variable based on a numeric one. For more advanced creation of dummy variables (e.g., for categorical variables) you should check out the [`fastDummies` package](https://github.com/jacobkap/fastDummies).

```{r dummy, eval = F}
gesis_panel_corona <- gesis_panel_corona %>% 
  mutate(married = ifelse(marstat == 1, 1, 0))
# read: if marstat equals 1, set the married to 1;
# otherwise set married to 0.
```

---

## Working with strings/text

Working with strings in R is a topic that would require its own workshop. The `tidyverse` package [`stringr`](https://stringr.tidyverse.org/index.html) offers a collection of convenient functions for working with strings.

```{r stringr-hex, out.width = "20%", echo = F}
include_graphics("./pics/hex-stringr.png")
```

As we cannot cover everything, we decided not to discuss working with strings and text in `R` in this course. However, `stringr` provides a good [introduction vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html), the book *R for Data Science* has a whole section on [strings with `stringr`](https://r4ds.had.co.nz/strings.html), and there also is an [*RStudio* Cheat Sheet for `stringr`](https://github.com/rstudio/cheatsheets/raw/master/strings.pdf).

If you want (or have) to work with [regular expressions](https://en.wikipedia.org/wiki/Regular_expression), you should also check out the [`rebus` package](https://github.com/richierocks/rebus) which allows you to create regular expressions in R in a human-readable way. Another helpful tool is the *RStudio* addin [`RegExplain`](https://www.garrickadenbuie.com/project/regexplain/).  

---

## Times and dates

As our focus in this course is on tabular data common to the social and behavioral sciences, we will not cover working with times and dates in `R`. If you are interested in this topic, you may want to look into the [`lubridate` package](https://lubridate.tidyverse.org/) which is part of the `tidyverse`, and for which *RStudio* also provides a [cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/lubridate.pdf).

```{r lubridate-hex, out.width = "20%", echo = F}
include_graphics("./pics/lubridate_hex.jpg")
```

If you work with time series data, it is also worth to check out the [`tsibble` package](https://tsibble.tidyverts.org/) for your wrangling tasks.

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2020/exercises/Day2_2_Data_Wrangling_Exercise_1_question.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2020/solutions/Day2_2_Data_Wrangling_Exercise_1_solution.html)

---

## Relational data

In some cases, you may need to combine different datasets (e.g., if you have seperate datasets from waves of a longitudinal survey study or data on the same subjects from different sources). 

The simplest case is that the dataframes you want to combine either have the same cases/rows in the same order but different variables/columns, or the same columns/variables (with the same names) but different cases/rows.

In those cases, you can use the `base R` functions `rbind()` to add/combine rows or `cbind()` to add/combine columns, or, better yet, `bind_rows()` or `bind_cols()` from `dplyr`.

---

## Relational data

For all other situations, you can use the `merge()` function from `base R`. However, a more convenient option is using the the so-called *two-table verbs* from `dplyr` which allow us to combine two (or more) tabular datasets in various ways. We will look at two categories of those verbs in the following:

1. Mutating joins  

2. Filtering joins  

If you have ever worked with (or at least seen) `SQL` code, many of the following things will look familiar. For a more in-depth introduction, you can have a look at the [chapter on relational data](https://r4ds.had.co.nz/relational-data.html) in *R for Data Science*.

---

## Superhero data `r ji("bat")``r ji("zap")``r ji("spider_web")``r ji("merman")`

As we cannot use the data from the *GESIS Panel Special Survey on the Coronavirus SARS-CoV-2 Outbreak in Germany* to illustrate the different joins from `dlpyr`, we will, instead, use data from the [Super Heroes dataset from *Kaggle*](https://www.kaggle.com/claudiodavi/superhero-set).

```{r superhero-data, include = F}
heroes <- read_csv("../../data/heroes_information.csv") %>% 
  select(name, Alignment, Race, Publisher) %>% 
  rename(Name = name) %>%
  mutate(Publisher = str_replace(Publisher, " Comics", "")) %>%
    filter(
    (Name == "Batgirl" & Race != "-") |
      Name == "Aquaman" |
      Name == "Catwoman" |
      Name == "Magneto" |
      Name == "Deadpool" |
      Name == "Poison Ivy" |
      Name == "Hellboy"
  )

publishers <- read_csv("../../data/heroes_information.csv") %>% 
  select(Publisher) %>%
  distinct() %>% 
  filter(
    Publisher == "Marvel Comics" |
    Publisher == "DC Comics" |
    Publisher == "Image Comics"
  ) %>% 
  distinct() %>%
  mutate(Publisher = str_replace(Publisher, " Comics", ""),
    Founded = case_when(
    Publisher == "Marvel" ~ 1939L,
    Publisher == "DC" ~ 1934L,
    Publisher == "Image" ~ 1992L
  ),
  Location = case_when(
    Publisher == "Marvel" ~ "NYC (NY)",
    Publisher == "DC" ~ "Burbank (CA)",
    Publisher == "Image" ~ "Berkeley (CA)"
  ))

```

.pull-left[
.center[
**Superheroes**
```{r superhero-table, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 16)
```
]
]

.pull-right[
.center[
**Publishers**
```{r publishers-table, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 16)
```
]
]

---

## Mutating joins

.large[
> A mutating join [...] .highlight[first matches observations by their keys], then .highlight[copies across variables from one table to the other] ([R for Data Science](https://r4ds.had.co.nz/relational-data.html#mutating-joins)).

- `inner_join()`  

- `left_join()`  

- `right_join()`  

- `full_join()`
]

---

## Inner join

 > All rows from `x` where there are matching values in `y`, and all columns from `x` and `y`.

.center[<img src="pics/inner-join.gif" width="50%">]

.small[
Animation by [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)
]

---

## Inner join example

.pull-left[
.center[
```{r superhero-table 2, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]

.pull-right[
.center[
```{r publishers-table-2, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]
<br>
```{r inber-join-display, eval = F}
heroes %>% 
  inner_join(publishers, by = "Publisher")
```

```{r inner-join-result, echo = F}
heroes %>% 
  inner_join(publishers, by = "Publisher") %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```

---

## Left join

> All rows from `x`, and all columns from `x` and `y`. Rows in `x` with no match in `y` will have `NA` values in the new columns.

.center[<img src="pics/left-join.gif" width="50%">]

.small[
Animation by [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)
]

---

## Left join example

.pull-left[
.center[
```{r superhero-table-3, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]

.pull-right[
.center[
```{r publishers-table-3, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]
<br>
```{r left-join-display, eval = F}
heroes %>% 
  left_join(publishers, by = "Publisher")
```

```{r left-join-result, echo = F}
heroes %>% 
  left_join(publishers, by = "Publisher") %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```

---

## Right join

> All rows from y, and all columns from `x` and `y`. Rows in `y` with no match in `x` will have `NA` values in the new columns.

.center[<img src="pics/right-join.gif" width="50%">]

.small[
Animation by [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)
]

---

## Right join example

.pull-left[
.center[
```{r superhero-table-4, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]

.pull-right[
.center[
```{r publishers-table-4, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]
<br>
```{r right-join-display, eval = F}
heroes %>% 
  right_join(publishers, by = "Publisher")
```

```{r right-join-result, echo = F}
heroes %>% 
  right_join(publishers, by = "Publisher") %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```

---

## Full join

> All rows and all columns from both `x` and `y`. Where there are not matching values, returns `NA` for the one missing.

.center[<img src="pics/full-join.gif" width="50%">]

.small[
Animation by [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)
]

---

## Full join example

.pull-left[
.center[
```{r superhero-table-5, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]

.pull-right[
.center[
```{r publishers-table-5, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]
<br>
```{r full-join-display, eval = F}
heroes %>% 
  full_join(publishers, by = "Publisher")
```

```{r full-join-result, echo = F}
heroes %>% 
  full_join(publishers, by = "Publisher") %>%
  kable("html") %>% 
  kable_styling(font_size = 9)
```

---

## Filtering joins

.large[
> Filtering joins .highlight[match observations in the same way as mutating joins], but .highlight[affect the observations, not the variables] ([R for Data Science](https://r4ds.had.co.nz/relational-data.html#filtering-joins)).

- `semi_join()`  

- `anti_join()`
]

---

## Semi join

> All rows from `x` where there are matching values in `y`, keeping just columns from `x`.

.center[<img src="pics/semi-join.gif" width="50%">]

.small[
Animation by [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)
]

---

## Semi join example

.pull-left[
.center[
```{r superhero-table-6, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]

.pull-right[
.center[
```{r publishers-table-6, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]
<br>
```{r semi-join-display, eval = F}
heroes %>% 
  semi_join(publishers, by = "Publisher")
```

```{r semi-join-result, echo = F}
heroes %>% 
  semi_join(publishers, by = "Publisher") %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```

---

## Anti join

> All rows from `x` where there are not matching values in `y`, keeping just columns from `x`.

.center[<img src="pics/anti-join.gif" width="50%">]

.small[
Animation by [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)
]

---

## Anti join example

.pull-left[
.center[
```{r superhero-table-7, echo = F}
heroes %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]

.pull-right[
.center[
```{r publishers-table-7, echo = F}
publishers %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```
]
]
<br>
```{r anti-join-display, eval = F}
heroes %>% 
  anti_join(publishers, by = "Publisher")
```

```{r anti-join-result, echo = F}
heroes %>% 
  anti_join(publishers, by = "Publisher") %>%
  kable("html") %>% 
  kable_styling(font_size = 10)
```

---

class: center, middle

# [Exercise](https://jobreu.github.io/r-intro-gesis-2020/exercises/Day2_2_Data_Wrangling_Exercise_2_question.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://jobreu.github.io/r-intro-gesis-2020/solutions/Day2_2_Data_Wrangling_Exercise_2_solution.html)

---

## Extracurricular activities

If you have not yet seen this, watch the famous [TED Talk by Hans Rosling](https://www.ted.com/talks/hans_rosling_the_best_stats_you_ve_ever_seen) on data visualization to get to know more about the background/roots of the [*Gapminder* project](https://www.gapminder.org/) and to get you in the mood for tomorrow's topic which is data visualization with `R`.

Check out the [*Tidy Tuesday* repository on *GitHub*](https://github.com/rfordatascience/tidytuesday), listen to a few of the very short episodes of the [*Tidy Tuesday* Podcast](https://www.tidytuesday.com/), check out the [#tidytuesday Twitter hashtag](https://twitter.com/hashtag/tidytuesday?lang=en), or watch one (or more) of the [*Tidy Tuesday* screencasts on *YouTube* by David Robinson](https://www.youtube.com/watch?v=E2amEz_upzU&list=PL19ev-r1GBwkuyiwnxoHTRC8TTqP8OEi8).